<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Three Fiber Christmas Tree - ayiii Edition</title>
    <style>
        body { margin: 0; background: #111; overflow: hidden; font-family: sans-serif; }
        #root { width: 100vw; height: 100vh; }
        
        /* UI ÂÆπÂô® */
        #ui-container {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }
        button {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 32px;
            border-radius: 30px;
            font-size: 16px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        button:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }

        /* ÊëÑÂÉèÂ§¥È¢ÑËßà */
        #webcam-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.5);
            z-index: 100;
        }
        #webcam-video, #webcam-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* Ê†áÈ¢ò */
        #title {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #FFD700;
            font-family: 'Brush Script MT', cursive;
            font-size: 4rem;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            pointer-events: none;
            z-index: 5;
        }

        /* ÊâãÂäøËØ¥Êòé */
        #gesture-info {
            position: absolute;
            top: 210px;
            right: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            text-align: right;
            z-index: 5;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
        }

        /* ÁÖßÁâáÂºπÁ™ó */
        #photo-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        #photo-modal.active { opacity: 1; pointer-events: auto; }
        #photo-modal img {
            max-width: 90%;
            max-height: 90%;
            border: 10px solid white;
            border-bottom: 40px solid white;
        }

        /* Á®≥Â¶•ÁöÑÂä®ÊÄÅÁ≠æÂêçÂÆπÂô® */
        #signature-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: auto;
            z-index: 110;
            pointer-events: none; /* Á©øÈÄèÁÇπÂáª */
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.4));
        }
        #signature-wrapper object {
            width: 100%;
            height: auto;
            display: block;
        }
    </style>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
                "three": "https://esm.sh/three@0.160.0",
                "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
                "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber"
            }
        }
    </script>
</head>
<body>
    <div id="root"></div>

    <div id="webcam-container">
        <video id="webcam-video" playsinline></video>
        <canvas id="webcam-canvas" width="320" height="240"></canvas>
    </div>
    <div id="gesture-info">
        <p>üñê Âº†ÂºÄÊâãÊéå: ÁàÜÁÇ∏ÊïàÊûú</p>
        <p>‚úä Êè°Êã≥: ÁªÑË£ÖÂú£ËØûÊ†ë</p>
    </div>

    <div id="title">Merry Christmas</div>

    <div id="signature-wrapper">
        <object type="image/svg+xml" data="https://raw.githubusercontent.com/ayiii007/XM4S/master/XM4S.svg"></object>
    </div>

    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Environment, OrbitControls, useTexture } from '@react-three/drei';

        const TREE_HEIGHT = 12;
        const MAX_RADIUS = 4;
        const COUNT = 2500;
        const COLOR_GOLD = "#FFD700";

        const tempObject = new THREE.Object3D();
        const tempColor = new THREE.Color();
        const tempPos = new THREE.Vector3();

        // Êï∞ÊçÆÁîüÊàê
        function generateTreeData() {
            const data = { leaves: [], ornaments: [], lights: [], photoSlots: [], ribbon: [] };
            for (let i = 0; i < COUNT; i++) {
                const t = i / COUNT;
                const angle = i * 2.39996;
                const y = t * TREE_HEIGHT - (TREE_HEIGHT / 2);
                const baseR = MAX_RADIUS * (1 - t);
                const layerWave = Math.sin(t * 25.0) * 0.8 * (1 - t);
                const typeRand = Math.random();
                let type = 'A';
                if (typeRand > 0.9) type = 'C';
                else if (typeRand > 0.7) type = Math.random() < 0.15 ? 'P' : 'B';

                let radiusOffset = (type === 'P') ? 0.65 + Math.random() * 0.1 : (type === 'B' ? 0.4 : (type === 'C' ? 0.25 : Math.random() * 0.2));
                const r = Math.max(0, baseR + layerWave + radiusOffset);
                const item = {
                    treePos: new THREE.Vector3(r * Math.cos(angle), y, r * Math.sin(angle)),
                    randomPos: new THREE.Vector3((Math.random()-0.5)*30, (Math.random()-0.5)*30, (Math.random()-0.5)*30),
                    id: i,
                    color: type === 'B' ? (Math.random() > 0.5 ? "#FFD700" : "#8a0a0a") : (type === 'C' ? ["#00FFFF", "#FF00FF", "#FFA500", "#FFFFFF"][Math.floor(Math.random()*4)] : null)
                };
                if (type === 'A') data.leaves.push(item);
                else if (type === 'B') data.ornaments.push(item);
                else if (type === 'C') data.lights.push(item);
                else data.photoSlots.push(item);
            }
            // ÈªÑÈáëÈ£òÂ∏¶
            for (let i = 0; i < 600; i++) {
                const t = i / 600;
                const angle = t * Math.PI * 2 * 6;
                data.ribbon.push({
                    treePos: new THREE.Vector3((MAX_RADIUS * t + 0.8) * Math.cos(angle), (1 - t) * TREE_HEIGHT - (TREE_HEIGHT / 2), (MAX_RADIUS * t + 0.8) * Math.sin(angle)),
                    randomPos: new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40),
                    id: i
                });
            }
            return data;
        }

        // ÂèåÈù¢ÁÖßÁâá
        function Polaroid({ position, randomPos, textureUrl, exploded, onClick }) {
            const meshRef = useRef();
            const texture = useTexture(textureUrl);
            useFrame((state, delta) => {
                if (!meshRef.current) return;
                const targetLerp = exploded ? 1 : 0;
                meshRef.current.userData.lerp = THREE.MathUtils.lerp(meshRef.current.userData.lerp || 0, targetLerp, delta * 2);
                const currentPos = new THREE.Vector3().lerpVectors(position, randomPos, meshRef.current.userData.lerp);
                meshRef.current.position.copy(currentPos);
                if (!exploded) { meshRef.current.lookAt(0, currentPos.y, 0); meshRef.current.rotation.y += Math.PI; }
                else { meshRef.current.rotation.x += delta * 0.5; meshRef.current.rotation.y += delta * 0.5; }
            });
            return (
                <group ref={meshRef} onClick={() => onClick(textureUrl)}>
                    <mesh><boxGeometry args={[0.6, 0.7, 0.04]} /><meshStandardMaterial color="white" /></mesh>
                    <mesh position={[0, 0.05, 0.021]}><planeGeometry args={[0.5, 0.5]} /><meshBasicMaterial map={texture} /></mesh>
                    <mesh position={[0, 0.05, -0.021]} rotation={[0, Math.PI, 0]}><planeGeometry args={[0.5, 0.5]} /><meshBasicMaterial map={texture} /></mesh>
                </group>
            );
        }

        // ÂÆû‰æãÂåñÁªÑ‰ª∂ (Leaves, Ornaments, Lights, Ribbon)
        function InstancedComponent({ data, exploded, geometry, material, isLight, isRibbon }) {
            const meshRef = useRef();
            useEffect(() => {
                if (data[0]?.color) {
                    data.forEach((d, i) => { tempColor.set(d.color); meshRef.current.setColorAt(i, tempColor); });
                    meshRef.current.instanceColor.needsUpdate = true;
                }
            }, [data]);
            useFrame((state, delta) => {
                const lerpTarget = exploded ? 1 : 0;
                meshRef.current.userData.lerp = THREE.MathUtils.lerp(meshRef.current.userData.lerp || 0, lerpTarget, delta * 2);
                data.forEach((d, i) => {
                    tempPos.lerpVectors(d.treePos, d.randomPos, meshRef.current.userData.lerp);
                    tempObject.position.copy(tempPos);
                    if (!isLight && !isRibbon) { tempObject.lookAt(0, tempPos.y, 0); tempObject.rotation.x += Math.PI/2; tempObject.scale.setScalar(1 - (d.treePos.y + 6)/12 * 0.5); }
                    if (isLight) tempObject.scale.setScalar(0.8 + Math.sin(state.clock.elapsedTime * 5 + i) * 0.2);
                    if (isRibbon) tempObject.rotation.set(state.clock.elapsedTime + i, state.clock.elapsedTime + i, 0);
                    tempObject.updateMatrix();
                    meshRef.current.setMatrixAt(i, tempObject.matrix);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
            });
            return <instancedMesh ref={meshRef} args={[geometry, material, data.length]} />;
        }

        function Star({ exploded }) {
            const ref = useRef();
            const geom = useMemo(() => {
                const s = new THREE.Shape();
                for(let i=0; i<10; i++){
                    const a = i * Math.PI / 5 - Math.PI/2;
                    const r = i % 2 === 0 ? 0.6 : 0.25;
                    if(i===0) s.moveTo(Math.cos(a)*r, Math.sin(a)*r); else s.lineTo(Math.cos(a)*r, Math.sin(a)*r);
                }
                const g = new THREE.ExtrudeGeometry(s, {depth:0.1, bevelEnabled:true, bevelThickness:0.05, bevelSize:0.05});
                g.center(); return g;
            }, []);
            useFrame((state, delta) => {
                ref.current.rotation.y += delta;
                ref.current.userData.lerp = THREE.MathUtils.lerp(ref.current.userData.lerp || 0, exploded ? 1 : 0, delta * 2);
                ref.current.position.lerpVectors(new THREE.Vector3(0, 6.6, 0), new THREE.Vector3(0, 20, 0), ref.current.userData.lerp);
            });
            return <mesh ref={ref} geometry={geom}><meshStandardMaterial color={COLOR_GOLD} emissive={COLOR_GOLD} emissiveIntensity={2} toneMapped={false} /></mesh>;
        }

        function App() {
            const [exploded, setExploded] = useState(false);
            const [selectedPhoto, setSelectedPhoto] = useState(null);
            const treeData = useMemo(() => generateTreeData(), []);
            const lastGesture = useRef('FIST');

            useEffect(() => {
                const videoElement = document.getElementById('webcam-video');
                const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
                hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
                hands.onResults((res) => {
                    const canvas = document.getElementById('webcam-canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.save(); ctx.clearRect(0,0,320,240); ctx.drawImage(res.image, 0,0,320,240);
                    if (res.multiHandLandmarks?.[0]) {
                        const l = res.multiHandLandmarks[0];
                        drawConnectors(ctx, l, HAND_CONNECTIONS, {color: '#00FF00'});
                        const openFingers = [8,12,16,20].filter(i => Math.hypot(l[i].x-l[0].x, l[i].y-l[0].y) > Math.hypot(l[i-2].x-l[0].x, l[i-2].y-l[0].y)).length;
                        if (openFingers >= 4 && lastGesture.current !== 'OPEN') { setExploded(true); lastGesture.current = 'OPEN'; }
                        else if (openFingers <= 1 && lastGesture.current !== 'FIST') { setExploded(false); lastGesture.current = 'FIST'; }
                    }
                    ctx.restore();
                });
                const camera = new Camera(videoElement, {onFrame: async () => await hands.send({image: videoElement}), width: 320, height: 240});
                camera.start();
            }, []);

            return (
                <>
                    <Canvas camera={{ position: [0, 2, 12], fov: 50 }}>
                        <color attach="background" args={['#111']} />
                        <React.Suspense fallback={null}>
                            <group position={[0, -2, 0]}>
                                <InstancedComponent data={treeData.leaves} exploded={exploded} geometry={new THREE.ConeGeometry(0.08, 0.25, 4)} material={new THREE.MeshStandardMaterial({color: "#003318"})} />
                                <InstancedComponent data={treeData.ornaments} exploded={exploded} geometry={new THREE.SphereGeometry(0.12, 16, 16)} material={new THREE.MeshStandardMaterial({roughness: 0.2, metalness: 0.8})} />
                                <InstancedComponent data={treeData.lights} exploded={exploded} isLight geometry={new THREE.BoxGeometry(0.1, 0.1, 0.1)} material={new THREE.MeshBasicMaterial({toneMapped: false})} />
                                <InstancedComponent data={treeData.ribbon} exploded={exploded} isRibbon geometry={new THREE.DodecahedronGeometry(0.06, 0)} material={new THREE.MeshStandardMaterial({color: COLOR_GOLD, emissive: COLOR_GOLD, emissiveIntensity: 3, toneMapped: false})} />
                                {treeData.photoSlots.map((s, i) => <Polaroid key={i} position={s.treePos} randomPos={s.randomPos} textureUrl="https://raw.githubusercontent.com/ayiii007/XM4S/master/shark.jpg" exploded={exploded} onClick={setSelectedPhoto} />)}
                                <Star exploded={exploded} />
                            </group>
                            <Environment preset="city" />
                            <OrbitControls enablePan={false} maxPolarAngle={Math.PI / 1.5} />
                        </React.Suspense>
                    </Canvas>
                    
                    <div id="ui-container"><button onClick={() => setExploded(!exploded)}>{exploded ? "ÁªÑË£ÖÊ†ë" : "ÂºïÁàÜÊÉäÂñú"}</button></div>
                    <div id="photo-modal" className={selectedPhoto ? 'active' : ''} onClick={() => setSelectedPhoto(null)}>{selectedPhoto && <img src={selectedPhoto} />}</div>
                </>
            );
        }
        createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
